import fs from 'node:fs';
import path from 'node:path';
import { format } from 'date-fns';
import matter from 'gray-matter';
import type { Heading as MdastHeading, PhrasingContent } from 'mdast';
import readingTime from 'reading-time';
import type { IReadTimeResults } from 'reading-time';
import remarkParse from 'remark-parse';
import { unified } from 'unified';
import { visit } from 'unist-util-visit';
import type { Heading, Post, PostFrontmatter, PostMeta } from '../model/model';

// root dir of posts
const postsDirectory = path.join(process.cwd(), 'app', 'blog-posts');

/**
 * Simple function to generate a URL-friendly slug from text.
 * Mimics the basic behavior of rehype-slug/github-slugger.
 * @param {string} text - The text to slugify
 */
function createSlug(text: string): string {
  if (!text) return '';
  return text
    .toLowerCase()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(/[^\w-]+/g, '') // Remove all non-word chars except -
    //.replace(/--+/g, '-') // todo: -- is generated by remark-slug
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, ''); // Trim - from end of text
}

/**
 * Extracts headings (h1-h6) from MDX content string.
 * @param {string} content - The MDX content to parse.
 */
function extractHeadings(content: string): Heading[] {
  if (!content || content.length === 0) return [];

  const headings: Heading[] = [];
  const tree = unified().use(remarkParse).parse(content);

  visit(tree, 'heading', (node: MdastHeading) => {
    let text = '';
    // Extract text content from heading children
    visit(node, ['text', 'inlineCode'], (child: MdastHeading | PhrasingContent) => {
      if (child.type === 'text' || child.type === 'inlineCode') {
        text += child.value;
      }
    });

    if (text && node.depth) {
      headings.push({
        text: text,
        depth: node.depth,
        slug: createSlug(text),
      });
    }
  });

  return headings;
}

/**
 * Gets the slugs (filenames without extension) of all MDX files
 */
export function getAllPostSlugs(): string[] {
  try {
    if (!fs.existsSync(postsDirectory)) {
      console.warn(`[BLOG] Posts directory not found at: ${postsDirectory}`);
      return [];
    }

    const fileNames = fs.readdirSync(postsDirectory);

    if (fileNames.length === 0) {
      console.info(`[BLOG] No files found in posts directory: ${postsDirectory}`);
      return [];
    }

    const mdxFiles = fileNames.filter((fileName) => {
      // check if the file is an MDX file
      if (!/\.mdx$/.test(fileName)) return false;

      // read the file to check if it's a draft
      const fullPath = path.join(postsDirectory, fileName);
      try {
        const fileContents = fs.readFileSync(fullPath, 'utf8');
        const { data } = matter(fileContents) as { data: Partial<PostFrontmatter> };

        return data.draft !== true || process.env.NODE_ENV !== 'production';
      } catch (error) {
        console.error(`[BLOG] Error reading file ${fileName}:`, error);
        return false;
      }
    }).map((fileName) => fileName.replace(/\.mdx$/, '')); // remove the .mdx extension

    if (mdxFiles.length === 0) {
      console.info(`[BLOG] No MDX files found in posts directory: ${postsDirectory}`);
    } else {
      console.debug(`[BLOG] Found ${mdxFiles.length} MDX files in posts directory`);
    }

    return mdxFiles;
  } catch (error) {
    console.error(`[BLOG] Error reading posts directory (${postsDirectory}):`, error);
    return [];
  }
}

/**
 * Gets the parsed data (frontmatter and content) for a single post.
 * @param {string} slug - The slug of the post.
 */
export async function getPostBySlug(slug: string): Promise<Post | null> {
  const fullPath = path.join(postsDirectory, `${slug}.mdx`);
  try {
    if (!fs.existsSync(fullPath)) {
      console.warn(`[BLOG] Post file not found for slug: ${slug}`);
      return null;
    }

    const fileContents = fs.readFileSync(fullPath, 'utf8');
    const { data, content } = matter(fileContents) as { data: Partial<PostFrontmatter>, content: string };

    if (data.draft === true && process.env.NODE_ENV === 'production') {
      console.info(`[BLOG] Skipping draft post in production: ${slug}`);
      return null;
    }

    const stats: IReadTimeResults = readingTime(content);
    const originalDate = data.date ? new Date(data.date) : new Date();

    const frontmatter: PostFrontmatter = {
      title: data.title ?? 'Untitled Post',
      date: data.date ?? originalDate.toISOString(),
      description: data.description ?? 'No description available.',
      tags: data.tags ?? [],
      draft: data.draft ?? false,
    };

    const headings = extractHeadings(content);

    return {
      slug,
      ...frontmatter,
      formattedDate: format(originalDate, 'PPP'),
      formattedLastModifiedDate: data.lastModified ? format(new Date(data.lastModified), 'PPP') : undefined,
      readTime: stats.text,
      content,
      headings,
      image: data.image ?? undefined,
    };
  } catch (error) {
    console.error(`[BLOG] Error reading or parsing post with slug ${slug}:`, error);
    return null;
  }
}

/**
 * Gets metadata for all posts, sorted by date descending.
 * Filters out posts marked as draft
 */
export async function getAllPostsMeta(): Promise<PostMeta[]> {
  const slugs = getAllPostSlugs();
  const postsPromises = slugs.map(async (slug): Promise<PostMeta | null> => {
    const fullPath = path.join(postsDirectory, `${slug}.mdx`);

    try {
      if (!fs.existsSync(fullPath)) {
        return null;
      }

      const fileContents = fs.readFileSync(fullPath, 'utf8');
      const { data, content } = matter(fileContents) as { data: Partial<PostFrontmatter>, content: string };

      if (data.draft === true && process.env.NODE_ENV === 'production') {
        return null;
      }

      const stats: IReadTimeResults = readingTime(content);
      const originalDate = data.date ? new Date(data.date) : new Date();
      const formattedDate = data.date ? format(originalDate, 'PPP') : ''; // todo: change this depending on country

      const meta: PostMeta = {
        slug,
        title: data.title ?? 'Untitled Post',
        date: data.date ?? originalDate.toISOString(),
        description: data.description ?? 'No description available.',
        tags: data.tags ?? [],
        draft: data.draft ?? false,
        formattedDate,
        readTime: stats.text,
        image: data.image ?? undefined,
      };
      return meta;

    } catch (error) {
      console.error(`[BLOG] Error processing metadata for slug ${slug}:`, error);
      return null;
    }
  });

  const posts = (await Promise.all(postsPromises))
    .filter((post): post is PostMeta => post !== null);

  // sort by date descending (newest first)
  return posts.sort((post1, post2) => {
    const date1 = post1.date && post1.date.length !== 0 ? new Date(post1.date) : new Date(0);
    const date2 = post2.date && post2.date.length !== 0 ? new Date(post2.date) : new Date(0);
    return date2.getTime() - date1.getTime();
  });
}
